using System;
using System.Collections.Generic;

namespace HomeTask_6
{
    // Данный класс предназначен для работы с графом через матрицу смежности.
    class Graph
    {
        public int[,] matrix; // Двумерный массив типа Integer для хранения матрицы смежности.
        public int[] nodes; // Одномерный массив типа Integer для храния вершин графа.
        public Graph()
        {
            matrix = new int[7, 7] { { 0, 1, 1, 0, 0, 0, 1 }, // Матрица смежности для графа.
                                     { 1, 0, 1, 1, 0, 0, 0 }, // В нашем графе будет 7 верши и 7 ребер.
                                     { 1, 1, 0, 0, 0, 0, 0 },
                                     { 0, 1, 0, 0, 1, 0, 0 },
                                     { 0, 0, 0, 1, 0, 1, 0 },
                                     { 0, 0, 0, 0, 1, 0, 1 },
                                     { 1, 0, 0, 0, 0, 1, 0 } };
        }
        public void BFS() // Реализация обхода в ширину.
        {
            Deque<int> deque = new(); // Создаем экземляр класса Deque (дек) типа Integer, для временного хранение рассматриваемых вершин.
            nodes = new int[7]; // Инициализируем наш массив вершин (по умолчанию все вершины помечены 0). 
            deque.AddLast(nodes[0]); // Добавляем нашу первую вершину в очередь.
            while(deque.GetCount() > 0) // Пока кол-во элементов в деке больше 0.
            {
                int node = deque.RemoveFirst(); // Извлекаем вершину из дека (извлекаем самую верхнюю вершину).
                nodes[node] = 2; // Отмечаем нашу вершину, как посещенную.
                for (int i = 0; i < nodes.Length; i++) // Проходимся по всем вершинам.
                { 
                    if (matrix[node, i] == 1 && nodes[i] == 0) // Проверяем для нее все смежные вершины.
                    {                     // Если вершина смежная и еще не была обнаружена(помечена), то
                        deque.AddLast(i); // добавляем ее в конец дека, 
                        nodes[i] = 1;     // а также отмечаем вершину как обнаруженную.
                    }
                }
                Console.WriteLine($"Current node: {node+1}"); // Выводим порядковый НОМЕР нашей вершины.
            }
        }
        public void DFS() // Реализация обхода в глубину.
        { 
            Stack<int> stack = new(); // Создаем экземпляр класса Stack, типа Integer для временного хранения рассматриваемых вершин.
            nodes = new int[7]; // Инициализируем наш массив вершин (по умолчанию все вершины помечены 0). 
            stack.Push(nodes[0]); // Добавляем нашу первую вершину в очередь.
            while (stack.Count > 0) // Пока кол-во элментов стека не равно 0.
            {
                int node = stack.Pop(); // Извлекаем вершину из очереди.
                if (nodes[node] == 2) continue;  // Если состояние извлеченной вершины - отмечена(просмотрена).
                nodes[node] = 2; // Отмечаем нашу вершину, как посещенную.
                for (int i = 6; i >= 0; i--) // Проход по массиву вершин с конца.
                { 
                    if (matrix[node, i] == 1 && nodes[i] != 2) // Проверяем для извлеченной вершины все смежные вершины.
                    {                  // Если вершина смежная и не обнаружена(помечена), то
                        stack.Push(i); // добавляем ее в cтек, 
                        nodes[i] = 1;  //  а также отмечаем вершину как обнаруженную.
                    }
                }
                Console.WriteLine($"Current node: {node + 1}"); // Выводим порядковый НОМЕР нашей вершины.
            }
        }
    }
}
